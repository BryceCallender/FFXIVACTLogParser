//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export abstract class ApiBase {
   private authToken: string;

   setAuthToken(token: string) {
       this.authToken = token;
   }

   protected constructor() {
   }

   protected transformOptions(options: RequestInit) {
      options.headers = {
         ...options.headers,
         'Authorization': `Bearer ${this.authToken}`
      };

      return Promise.resolve(options);
   }
}

export class ReportClient extends ApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:7000";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateReportRequest | undefined, signal?: AbortSignal): Promise<CreateReportResponse> {
        let url_ = this.baseUrl + "/api/report/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<CreateReportResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateReportResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateReportResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    encounter(body: AddEncounterRequest | undefined, signal?: AbortSignal): Promise<AddEncounterResponse> {
        let url_ = this.baseUrl + "/api/report/encounter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEncounter(_response);
        });
    }

    protected processEncounter(response: Response): Promise<AddEncounterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AddEncounterResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddEncounterResponse>(null as any);
    }

    /**
     * @return OK
     */
    report(reportKey: string, signal?: AbortSignal): Promise<GetReportResponse> {
        let url_ = this.baseUrl + "/api/report/{reportKey}";
        if (reportKey === undefined || reportKey === null)
            throw new Error("The parameter 'reportKey' must be defined.");
        url_ = url_.replace("{reportKey}", encodeURIComponent("" + reportKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processReport(_response);
        });
    }

    protected processReport(response: Response): Promise<GetReportResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetReportResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetReportResponse>(null as any);
    }

    /**
     * @return OK
     */
    zones(signal?: AbortSignal): Promise<ZoneResponse> {
        let url_ = this.baseUrl + "/api/report/zones";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processZones(_response);
        });
    }

    protected processZones(response: Response): Promise<ZoneResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ZoneResponse;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ZoneResponse>(null as any);
    }
}

export interface AddEncounterRequest {
    encounterNumber?: number;
    start?: Date | undefined;
    end?: Date | undefined;
    zoneId?: number;
    reportKey?: ReportKey;
    players?: Combatant[] | undefined;
    pets?: Pet[] | undefined;
    bossNpcs?: BossNPC[] | undefined;
    events?: ReportEvent[] | undefined;
}

export interface AddEncounterResponse {
}

export interface BossNPC {
    sourceId?: number;
    name?: string | undefined;
    mainInstanceId?: number;
    instanceNumber?: number;
}

export interface Combatant {
    name?: string | undefined;
    sourceId?: number;
    jobId?: number;
}

export interface CreateReportRequest {
    reportName?: string | undefined;
}

export interface CreateReportResponse {
    reportKey?: ReportKey;
}

export interface Fight {
    fightNumber?: number | undefined;
    zone?: number | undefined;
    clear?: boolean | undefined;
    hpPercentageLeft?: number | undefined;
    start?: Date | undefined;
    end?: Date | undefined;
}

export interface GetReportResponse {
    reportName?: string | undefined;
    created?: Date | undefined;
    fights?: Fight[] | undefined;
}

export enum LogMessageType {
    LogLine = "LogLine",
    ChangeZone = "ChangeZone",
    ChangePrimaryPlayer = "ChangePrimaryPlayer",
    AddCombatant = "AddCombatant",
    RemoveCombatant = "RemoveCombatant",
    AddBuff = "AddBuff",
    RemoveBuff = "RemoveBuff",
    FlyingText = "FlyingText",
    OutgoingAbility = "OutgoingAbility",
    IncomingAbility = "IncomingAbility",
    PartyList = "PartyList",
    PlayerStats = "PlayerStats",
    CombatantHP = "CombatantHP",
    ParsedPartyMember = "ParsedPartyMember",
    NetworkStartsCasting = "NetworkStartsCasting",
    NetworkAbility = "NetworkAbility",
    NetworkAOEAbility = "NetworkAOEAbility",
    NetworkCancelAbility = "NetworkCancelAbility",
    NetworkDoT = "NetworkDoT",
    NetworkDeath = "NetworkDeath",
    NetworkBuff = "NetworkBuff",
    NetworkTargetIcon = "NetworkTargetIcon",
    NetworkTargetMarker = "NetworkTargetMarker",
    NetworkBuffRemove = "NetworkBuffRemove",
    NetworkGauge = "NetworkGauge",
    NetworkWorld = "NetworkWorld",
    Network6D = "Network6D",
    NetworkNameToggle = "NetworkNameToggle",
    NetworkTether = "NetworkTether",
    NetworkLimitBreak = "NetworkLimitBreak",
    NetworkEffectResult = "NetworkEffectResult",
    NetworkStatusList = "NetworkStatusList",
    NetworkUpdateHp = "NetworkUpdateHp",
    Settings = "Settings",
    Process = "Process",
    Debug = "Debug",
    PacketDump = "PacketDump",
    Version = "Version",
    Error = "Error",
    Timer = "Timer",
}

export interface Pet {
    sourceId?: number;
    name?: string | undefined;
    ownerId?: number;
}

export interface ReportEvent {
    type?: LogMessageType;
    content?: any | undefined;
}

export interface ReportKey {
    key?: string | undefined;
}

export interface Zone {
    id?: number;
    name?: string | undefined;
    fileName?: string | undefined;
}

export interface ZoneResponse {
    zones?: Zone[] | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}